Class: 
------- 
Classes are just like blueprint. 
classes are going to represent how an entity should look and behave. 

when i say how do they look that mean the property they posses and when i say how do they behave that mean action they perform 

Lets talk about the propery they posses which are otherwise known as the Data Members for examle: 

Just take an example of a Product Class so what are the properties of a product.

price,
quantity,
productName,
reviews

Now lets talk about the actions they perform that mean which are otherwise known as Member Functions: 

We can Display the details of the product
We can buy a Product
we can wishlist a product
we can rate a product
adding review to a product
adding product to the cart

// How to make a class in Javascript 
with the help of class keyword we can make a class in Javascript. 

class Product {
    // here we can add some data member and member functions
}

Example: 
--------
class Product {

    // writting some data members: 

    name
    price
    category
    description
    quantity

    // writing some member functions
 

    addToCart(){
        console.log('product added to the cart')
    }

    DisplayDetails(){
        console.log('display details of the product')
    }


}

// no need of writting function while creating a member function we  can just write simply name of the member function

    . function addToCart() - not required
    . addToCart() - this is great

// Constructor: 
---------------
. Every class in javascript has one special member function called as constructor which is only executed once at the time of object creation and that too it will be the first method to get execute. 

. whenever we create an object and try to execute it constructor will be first one to get execute out of all the methods and the constructor is the method which get automatically called by JS. 

. Koi bhi class ham banaye usmein bydefault kuch constructor bane banaya milega , already available for any class which is called as default constructor.

. Yeah jo constructor hai thoda diffrent hai kyun ki yeah ek hi method hai jo javascript khud se call kar dega baki kisi bhi member function ko javascript khud se call nahi karega 



Objects:
-------
The physical Realisation of the class are called Objects
To create an Object in JS we use a keyword called new

// How new works: 
-----------------
Every time we use new it does four following procedure

1. It creates a brand new absolutely empty object. 
2. It calls the constructor of the class and passes the newely created object inside a keyword called this. 
    (constructor ko call karega and apne jo empty plain object banaya hoga usko pass karega but parameter ke tarah pass nahi karega constructor ke andar ek this keyword ka access hoga and ham us plain object ka access us this keyword ko de denge, this keywrod ko aceess kaise mil raha hai kyun ki ham plain object ka access de rahe hein)
3. In step 3 new trigger everything we need to be done for prototype.

4. if from a constructor an object is manually returned then this manual returned object is stored in the called variable, otherwise in any other case either we return something or dont return something constructor doesnot care about it and returns the value inside the this key. 

for example :

    class Product{
        constructor(){
        return 10
        }
    }
    const data = new Product()
    console.log(data)

    data = this i.e the Product
    
    if i do like this then i will get the the whole product where this will be pointing i.e the product object. 

    class Product{
        constructor(){
        return {name: 'deepak'}
        }
    }
    const data = new Product()
    console.log(data)
    but here i will get {name : 'deepak'}

    data = {name: 'deepak'}
 

   
Explanation in Hindi Point4:
-----------------------------
aggar aap constructor se koi object manually return kar rahe ho toh apko wohi object milega as a result par aggar aap koi aur chiz return kar rahe ho (Look at the code above for more clear understanding meine eske liye bhi examples likha hai) so tab mujhe hamara actual product milega jo this ko pointout kar raha ho. 

Program/; 
--------

class Product {
    name;
    category;
    quantity;
    description;
    rating;

    constructor(productName, productCategory, productQuantity, productDescription, productRating){

        this.name = productName; // Laptop
        this.category = productCategory; // Electronics
        this.quantity = productQuantity; // 12
        this.description = productDescription; // Hp Laptop
        this.rating = productRating // 4.0

        addToCart(){
            console.log('product added to the cart')
        }

    }
}

const productOne = new Product('Laptop','Electronics',12, 'Hp Laptop', '4.0')
// aggar apko new data members add karna hai toh aap object ke help se kar sakhte ho called variable ko leke for example; 
productOne.color = "black"
console.log(productOne)

Product {
  name: 'Laptop',
  category: 'Electronics',
  quantity: 12,
  description: 'Hp Laptop',
  rating: '4.0',
  color: 'black'
}

Note: 
-----
aggar mein data member nahi bhi define karun aur directly constructor ke andar define karun like 
this.name = product_name
then also its okay we will not get any error infact when we console productOne then i will get the actual product.
i can also access the productname like console.log(productOne.name)


This keyword in Javascript:
----------------------------
This keyword works very diffrently in compare to other languages. 
lets get to know more with help of an examples : 

let obj = {
    x : 10;
    y : 20;
    fn : function(){
        console.log(this.x, this.y)
    }
}

obj.fn()

in this example this is referring to the obj and obj here will act as a callsite. we can also access the same thing using obj.x , so here
in thie example this is actualy referring to callsite which is obj
Example 2: 
----------

let obj = {
    x : 10;
    y : 20;
    z : {
        x : 99;
        fn : function(){
            console.log(this.x, this.y)
        }
    }
}

In the above example this is referring to z here so thats why this.x will be pointing to 99 but for this.y i will get undefined why because inside z i havn't defined y , i have done that in obj. but here this is referring to z not obj. (callsite iz z not obj)

How this is used in arrow function: 
-----------------------------------
let obj = {
    x : 10;
    y : 20;
    fn : ()=>{
        console.log(this.x, this.y)
    }
}

obj.fn()

so what do you think whm does this is referring to here in the above example if we are using this inside the arrow function then it will never refer it to the callsite so we have to do some changes in arrow function this is defined lexically. 

let obj = {
    x : 10;
    y : 20;
    fn : function(){
        const arw = () => {
            console.log(this.x, this.y)
            // 10 , 20
        }
    }
}

obj.fn()

so how i am getting 10 and 20 here because this is being defined here lexically that mean aggar hame arw ke andar nahi mile the value of x and y toh yeah ek level upar jaega that mean inside fn kya fn ke andar this defined hai haan par kaise callsite pe and obj is the call site

so the point is aggar aap ek arrow function ke andar this ko access karna chahoge then it wont happen par aap us arrow function ko aggar ek normal function mein enclose karoge toh usko this ka value milega kyun ki normal function ke andar this callsite ko point out karta hai which is obj here in this example and thats why we are getting the value as 10,20 

// So how to add data-members without providing value through constructor. 
class Product {
    name;
    age;

    constructor(){

    }
}

const data = new Product()
data.name = "deepak"
data.age = 30

console.log(data)

look at the above program where i am adding some valus but i am not doing that through constructor so this is one way where i can add some values but this is not the right thing to do because just look at the code how i am adding the values after object creation i mean anyone can do some sort of changes even after the object creation without any issues which violates the fundamental princicple of OOPS called as encapsulation that means classes ke bahar ham data members ko update nahi kar sakhte and jo ki usually hota bhi nahi hai.

kyun ki agar aisa hua then koi bhi akke kuch bhi random value pass kar dega and update lar dega which is not required, par es sab chiz ko ham resolve bhi kar sakhte hein but not simply allowing your data members from being accessible outside the class and is to be done only inside the class (update and accessible)

so we can make private to the data members so that it can be accessible/updatable only inside the class not from outside. and how to make the datamembers prive just to add # before declaring the datamember for example: 

class Product {
    #name; this is a private data member
    #age; this private data member
}

// so now theese datamembers cannot be access outside the class neither can be updateable outside the class
Example: 

class Product {
    #name;
    #quantity;
    #rating;
    review;
    price;

    constructor(productName, productQuantity, productRating, productReview, productPrice){
        this.#name = productName;                   
        this.#quantity = productQuantity;
        this.#rating = productRating;
        this.review = productReview;
        this.price = productPrice;
    }

}
const productOne = new Product('hp-laptop','14','4.2','Good One',67000)
console.log(productOne)

// Product { review: 'Good One', price: 67000 }

// see though i have make it private so iam unable to acess it from outside node js runtime mein apko basi yahi dikhai de raha hai aggar mein same chiz ko browser mein check karunga toh mujhe thoda allag sa result aega like asia esliye aa raha kyun ki dono ka kam karne ka tarika allag hai browser and nodejs: 

// Product {review: 'Good One', price: 67000, #name: 'hp-laptop', #quantity: '14', #rating: '4.2'} but you can clearly see that apko kuch data members mein #name , #quantity, #rating aur woh esliye kyun ki meine en data-members ko private jo banaya tha aur haan aggar mein enko update karna chahun toh bhi nahi kar sakhta jo jo data-members meine private banaya hai uska value kabhi change nahi hoga par ek naya allag se name ban jaega jo ki private hoga hi nahi par jo private hai us mein koi bhi changes nahi hoga infact ek naya ban jaega for example: 

productOne.name = "hp"
Product { review: 'Good One', price: 67000, name: 'hp' }
this is what it will happpen but it wont be changing the value which i have made private.

productOne.#name = "hp"
//Property '#name' is not accessible outside class 'Product' because it has a private identifier.
// but aggar mein yeah same chiz browser se karunga toh change ho jaega but terminal se nahi hoga.

and yes they way we are making data-members private these are the old school technique.

// So its very Crystal Clear that aap bahar se change nahi kar sakhte private-members ko par aap class ke andar kar sakhte ho and lets see with an example how to do ..  with the help of getter and setter functions

    class Product {
        #name;
        #quantity;
        #rating;
        review;
        price;
    
        constructor(productName, productQuantity, productRating, productReview, productPrice){
            this.#name = productName;                   
            this.#quantity = productQuantity;
            this.#rating = productRating;
            this.review = productReview;
            this.price = productPrice;
        }
    
        // how to writer a actual setter and getter function by using set and get so i have done this by using get and set keyword
        
        set price(p){
            if(p > this.price){
                this.price = p
            }else{
                console.log('please choose a higher/updated price')
            }
        }
        get price(){
            return this.price
        }
    
    }
    const productOne = new Product('hp-laptop','14','4.2','Good One',67000)
    
    //productOne.setName('HP')
    productOne.price = 90000;
    console.log(productOne.price)
    console.log(productOne)

// So classes jo hai woh pehle nahi hua karta tha classes toh newely implement hua tha but ussse pehle bhi without classes ham function ke help se bhi same chiz kar pate they , this is known as function constructor javascript mein aggar mein class ko use nahi karunga but still class jaise functionality mujhe chahiye toh uske liye mein function constructor use kar sakhta hoon

    function Product(n,d,p){
        this.name = n;
        this.description = d;
        this.price = p;
    
        this.displayProductDetails = function(){
            console.log(this.name,this.description,this.price)
        }
    
    }
    
    const data = new Product('laptop','hp-laptop',78999)
    data.displayProductDetails()

    // Output : laptop hp-laptop 78999

// ek chiz apne notice kiya ki class anur abhi jo meine likha hai kaise mein new Product banata hun arguments pass karke dono mein same hai class main apko ek constructor banana padhta par yahan koi banane ki jarurat nahi hai  aur yana pe mein koi class bhi define nahi kar raha hoon and yeahi hai woh traditional tarika jisse pehle class keyword introduce hone se pehle ham essi tarah blueprinting kari jati thi and yahan pe private members ki koi bhi faciity nahi thi 


Static Members: 
---------------
Static members woh data-members hote hein jo object ke saath associated nahi hote hein class ke hote hein for example: 


class Product {
    static x = 10; 
    constructor(name, price){
        this.name = name
        this.price = price
    }
}
const p1 = new Product('Iphone',1500000)
console.log(p1.x) // you are trying to access static member and that too with the help of an Object but static members are not associated with Objects

console.log(Product.x)
// so here you can access it, it is accessible outside the class and here we are accessing with the help of an class

// Code Improvisation
---------------------
class Product {
    
    constructor(obj){
        this.name = obj.name;
        this.modelno= obj.modelno;
        this.quantity = obj.quantity;
        this.price = obj.price
    }

    getDetails(){
        return `
        ${this.name}, ${this.modelno},${this.quantity}, ${this.price}
        `
    }
}

const Iphone = new Product({
    name: 'Iphone',
    modelno : 'Iphone14',
    quantity: 14,
    price : 150000,
})

console.log(Iphone.getDetails())

// so now the code is looking even more good then the previous one they way i have created an object during calling this is called builder design pattern

Object Destructuring: 
----------------------
// Example for object destructuring: 
const product = {name: 'Iphone',price:80000,quantity:30}

// changing the keyname for name so now we can aceess by using nameee not name. 
const {name:nameee,price,quantity} = product

console.log(nameee)
console.log(price)
console.log(quantity)

Using Spread Operator in Objects Destructuring: 
-----------------------------------------------
const productData = {review : 'Its very Costly', description: 'The Phone is Very Good But Very Costly', ...product}
console.log(productData)

so i can also use spread operator like this in Object destructuring

// how to access nested objects on Object Destructuring: 
---------------------------------------------------------
const product = {name: 'Iphone',price:80000,quantity:30, product_Info: {review : 'Its very Costly', description: 'The Phone is Very Good But Very Costly' }}

const {product_Info: {review,description}} = product
console.log(review)
console.log(description)

// Another Example: 
const bioData = {name: 'deepak',surname: 'kumar', address:{location:'odisha', district:'cuttack',area:'CDA', Hobbies:{hobbieOne:'cricket', hobbbieTwo:'Coding', hobbieThree: 'Listening Songs'}}}

// How to access hobbieThree
const {address:{hobbies:{hobbieThree}}} = bioData

const {address:{Hobbies:{hobbieThree,hobbieOne,hobbbieTwo}}} = bioData
console.log(hobbieThree) : Li


ˀstening Songs
console.log(hobbbieTwo)  : Coding
console.log(hobbieOne)   : cricket


Three Dot Operator: 
-------------------
in objects we use spread operator as it upacks key value pair.
and the rest parameter packs into one unit. 


Prototype:
----------
Is JavaScript is a Object Oriented Programming Language.. The answer is No Its a Object Linked to an Object Kind of Language because of prototype


Prototype ek aisa mechanism hai javascript mein jiske help se ek object aur ek object ko apna properties share kar sakhta hai

One Object can share its Properties to Another Object

 

const p = new Product('Iphone',12000)

// jaise ki yahan jab bhi mera constructor execute karta hai kya mein kabhi yahan pe koi bhi member function ko hit karta hoon nahi na kabhi nahi karta but still mein acess kar pata hoon displayProductDetails() member function ko and woh kaise ho raha hai woh ho raha hai prototype ke vajeh se kyun ki yeah jo hamara member function hai na yeah wala function apko prototype ke andar dekhne ko milega.

jab bhi mein ek object create karta hoon woh pehle ek empty object banaega and banane ke baad woh constructor ko call karega par aap ek baat dekhna kabhi bhi member function ko hit karega hi nahi.

. data member ka access de raha hoon par function ka access nahin de raha hoon.

Prototypes Example: 
-------------------
class Events {
    bookEvents(name){
        this.name = name
        console.log('Event Booking Done for',this.name)
    }
}

class Movie extends Events {
    showTime(){
        console.log('movie-show')
    }
}

const m = new Movie()
m.showTime()
m.bookEvents('movies')

. aggar mein es example mein dekhun toh kya bookEvents object mein available hai.. nahi hai.. 
. kya book event movie pe available hai .. nahi hai 
. kya book event Events pe available hai haan hai.

// So Above example mein i used classes to show thw example of inheritance now we will do without classes by the helo of call, apply, bind in Javascript. 


Call: 
-----
the call function tells us that where is my this is now pointing t0.

    const product = {
        name : 'Iphone',
        productInfo : function(){
            console.log(this.name)
        }
    }
    
    const productTwo = {
        name : 'Audi car'
    }
    product.productInfo.call() // undefined

    if i want my this to attach with another object (productTwo) so for that i can write. 
    product.product_Info.call(productTwo) // Audi Car.

    if i want to pass some extra parameter then also i can do it like: 
    product.product_Info.call(productTwo, 'parameter','parameter')


    // call example how to pass argument

    const product_one = {
        name : 'Iphone',
        getInfo : function(price){
            console.log(this.name,'price is',price)
            // so here i am passing a parameter as price in getInfo function
        }
    }

    const productTwo = {
        name : 'Macbook'
        
    }

    //product_one.getInfo(50000)
    product_one.getInfo.call(productTwo, 67000)
    // 67000 mein esliye pass kar raha hoon kyun ki getinfo ko ek parameter chahiye and woh parameter aise hi paas hogi after comma and more than one ham pass kar sakhte hein. 


    // One more example with call: 
    var name = "Earpods"
    const obj = {
        name : "Iphone",
        getInfo : function(){
            console.log(this.name)
        }
    }

    const newObj = {
        name :'Macbook'
    }

    obj.getInfo.call()
    aggar mein kuch bhi object provide nahi kar raha hoon then hame this jo hai point out karega global ko (window) and global mein  
    this.name = "Earpods"

Apply: 
-----
By the help of apply also i can do the same thing , doing the same thing mean pointing this to some other function.
    const product = {
        name : 'Iphone',
        productInfo : function(price){
            console.log(this.name, 'and the price is',price)
        }
    }
    
    const productTwo = {
        name : 'Samsung Galaxy'
    }
    
    product.productInfo.apply(productTwo, [120000])

if i want to pass some arguments then i can pass it but i have to pass it inside the square brackets they way i have passed it in an the above example

So in Apply i can take two arguments one is the object and the other one is the arguments that too inside the array and we can take number of arguments but have to write it inside the array for example.

product.product_Info.apply(newObj, [arg1, ar2, ar3, arg4])

see i am passing 4 arguments and i have written that inside an array.

Bind:
------
var name = "Earpods"
const obj = {
    name : "Iphone",
    getInfo : function(){
        console.log(this.name)
    }
}

const newObj = {
    name :'Macbook'
}

const f = obj.getInfo.bind(newObj)
console.log(f)

. bind return us a modified function of getInfo. the original getInfo function mein koi changes nahi hoga but ek naya  modified function milega because of bind

// Example 2 for bind:
-----------------------
const product = {
    name : "IPhone",
    getInfo : function(price){
        console.log('my phone name is',this.name, 'and its price is',price)
    }
}

const product2 = {
    name : "Macbook"
}
const data = product.getInfo.bind(product2)
data('12000')

Output:
-------
my phone name is Macbook and its price is 12000

// Example of prototype without using class how to do it with function.
    function Events(date){
        this.date = date
    }
    Events.prototype.bookEvent = function(eventname){
        if(eventname === 'Movie'){
            console.log('Congratulations Ticket Book Successfully for',this.name)
        }else if(eventname === 'Comedy'){
            console.log('Congratulations Ticket Book Successfully for',this.name)
        }else{
            console.log('Congratulations Ticket Book Successfully for',this.name)
        }
    }
    
    function Movie(name){
        this.name = name
    }
    
    function Comedy(name){
        this.name = name
    }
    function Circus(name){
        this.name = name
    }
    
    // this will connect movie with events
    Movie.prototype.__proto__ = Events.prototype

    // this will connect comedy with events
    Comedy.prototype.__proto__ = Events.prototype

    // this will connect circus with events
    //Circus.prototype.__proto__ = Events.prototype

    You can try something like: 
    Circus.porototype = Object.create(Events.prototype)
    
    const m = new Movie('KGF')
    m.bookEvent('Movie')
    
    const c = new Comedy('Kapil Sharma Show')
    c.bookEvent('Comedy')
    
    const cir = new Circus('The Circus Show')
    cir.bookEvent('Circus')
    
// how to do the same trying with class:

        class Events {
            constructor(dateofEvent) {
                this.dateofEvent = dateofEvent
            }
            bookEvent(eventname) {
                if (eventname === 'Movie' || 'movie') {
                    console.log('Congratulations Ticket Booked Successfully for', this.name)
                } else if (eventname === 'Comedy' || 'comedy') {
                    console.log('Congratulations Ticket Booked Successfully for', this.name)
                } else {
                    console.log('Congratulations Ticket Booked Successfully for', this.name)
                }
            }
        }
        
        class Movie extends Events {
            constructor(name, date) {
                super(date) // call the events constructor
                this.name = name
            }
        }
        
        class Comedy extends Events {
            constructor(name,date){
                super(date) // this is right always use super before this
                this.name = name
                //super(date) cannot access this before super
            }
        }
        
        const m = new Movie('KGF', '19-02-2025')
        //m.bookEvent('movie')
        
        const c = new Comedy('Kapil Sharma Show', '19-02-25')
        c.bookEvent('comedy') 
    
   
Some Important Notes: 
---------------------
what super is actually doing here...
    when we want to access the properties of parent class inside the child then at that time we have to use super and in javascript whule exteding a class we must use super, and we have to class super before accessing this inside the child constructor otherrwise we will get an error as: 

Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor

and if we have any logic or if we have defined any member function then javascript also allows the member function to execute from the parent function.