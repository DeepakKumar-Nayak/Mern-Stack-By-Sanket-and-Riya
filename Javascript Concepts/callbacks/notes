Higher Order Function :- A function which accept another function as an argument is known as Higher Order Function .. 

Callback Function : A function which is being passed to another function as an argument is known as callback function 

Higher order function accepts it. and callback is passed into an function that too as an argument. 

for example: 
------------
arrayOne = [10,20,30,40,50]

const data = arrayOne.map(function getElement(element){
    return element*2
})

console.log(data)

so here map is a higher order function. 
getElement is an callback function. 


Callback Hell: 
--------------
callback hell is known for its dis-advantage instead of advantages because callback hell is a readibility problem which is a minor problem , because there is something else which is much more bigger problem then this readibility problem and that is known as inversion of control where we are going the give power to someone else to the third person which will eventually create a big problem. 

Callbacks heavily used hote hein Async Programming mein . And Async programming mein 2 types ke hote hein 

1. Sync Programming - jo line by line execute hoga for example aggar hamare pass 3line of code hai toh kya hoga 1st line execute hone ke baad hi 2nd wala line execute hoga then 3rd hoga so har ek chiz line by line hoga. 

2. Async Programming - jaise ki hamaare pass 5 line of code hein toh hamara 1st line of code execute hone ke baad 2nd line backend mein execute ho raha hoga but khatam nahi hua hoga and 3rd line ko chala gaya and 3rd line execute ho gaya and so on and baad mein kabhi 2nd line ho gaya execute so yahan pe kuch bhi line by line nahi hota hain. Async mein line by line execute hoga kabhi bhi aisa 1st line ke baad 3rd ko nahi jaega and baad mein kabhi 2nd wala line execute hogaya yeah sab Sync mien nahi hota hein. 


So jo ham javascripr ka code likhte hein kya woh async hai ya sync hai .. the answer is any native peice of javascript code matlab javascript ka jitna bhi apna khud ka code hai woh sare ke sare Sync nature ke hote hein, aur baki sab async hein 

for example for loop javascript ka khud ka code hai, woh hamesha sync nature ka hai ek for loop execute hoga uske baad dusra execute hoga ek ke baad hi dusra hoga. 

for example: 
for(let i=0; i<=10; i++){
    // console i 
}

for(let i=0; i<=20; i++){
    // console i
}

console.log('its over')


Javascript jo hai hamara bahut hi basic language hai , aab Javascript ko modern capabilites ke saath use karne ke liye bahut sare features lagte hein 

jaise ki javascript ko files read karna nahi atta hai, javascript ko timer run karna nahi atta, Javascript ko html ke saath kaise interact karna nahi atta and also javascript ko nwtwork ke saath bhi interact karna nahi atta hai insort javascript ko bahut sare chiz nahi atta hai jo aaj kal modern applications mein use hote hain

aur aggar hame woh sare ke sare fearues ko run karna hai toh uske liye Javascript ko ek sutitable environment ki jarurat hai jahan javascript apni capabilities se agge badh kar kuch kar paye and aise environment ko ham bolte hein runtime environment . 

runtime environment ek software hai jo Javascript ko help karta hain naye naye requirements ko poora karne ke liye.

jaise ki browser, woh bhi ek software hai jo javascript ke naye naye features ko run karne ke liye help karta hein

and aur ek jo ki hai nodejs so nodejs ke help se bhi main bahut sare functionality use kar paenga aur yeah jo capabilities hai woh javascript ka part nahi nahi woh nodejs, browser ka part hai   


Closure
--------
Closure is a mechanism using which any inner function remembers all those variables which are defined in the outer function scope even when the outer function scope executon is completed. for example: 

    function func(a,c){
        let m = 10
        function gun(){
            console.log(m,c)
        }
        return gun;
    }
    
    const g = func(10,20)
    g()

jab mein kuch return kar raha hoon that means woh chiz gayab ho jaega callstack se es mein g mein function func hai and woh function gayab ho jaega callstack se and still gayab hone ke baad bhi gun ko m and c ka values yaad hai and that is because of closure. 

and what about those variables which are not used like a, i am not accessing anywhere not even in the inner function so its simple that ki woh memory mein se hat jaega, aap usko use krna chahte ho toh aap kar sakhte ho but aggar aap nahi kar rahe ho use that means hat jaega memory se. 


--------
so we are talking about callback hell and inversion of control, so callback hell is a readibility problem which is not a big prpblem eventually but inversion of control is a very big probelm because when you pass your callback to another function that means you are giving aap kisi aur ko woh hak de rahe ho call karne ke liye usko execute karne ke liye, callback impliment toh apne kiya tha but execute karne ke liye aap kisi aur ko de rahe ho par woh execute hogi bhi ya nahi ya phir kitni bar hogi execute iska control aap kisi aur ko de rahe ho and aisa bhi ho sakhta hai ki apka function ko woh galat tarike se use kar sakhta hai kyun ki function toh apka tha implimentation toh apka tha but apne control toh kisi aur ko diya hai na aur woh kuch bhi kare woh apke haath mein hai hi nahi aggar apne apke pass control rakha tha toh accha hota par abhi toh apne kisi aur ko de diya hai na control so yeah ek bahut bada problem hai 

but es problem ko resolve kaise karte hai uske bare mein baat karte hein jo javascript ne offcialy launch kiya hai woh hai promise , 

Promises jo hai woh Inversion of Control ko end to end solve kar dete hein and callback hell ka bhi but initially promises ko callback ka solution nahi mana jata hai kyun ki promises ka khud ka ek problem hai jisko kehte hein promise hell toh callback hell ko thikkarne ke chakkar mein aap promise hell ko introduce kar sakhte ho kyun ki jaise callback hell ek readibility problem hai waise promises hell bhi ek readibility problem hai (code saf sutra nahi rakhna, padha nahi jata) so promises ko IOC ka full solution and callback hell ka thoda bahut solution mana jata hai 

Promises: 
Promises is a good elternative for callback, aggar future mein hame kuch kam ko complete karna hai toh uske liye hame promise use kar sakhte hai par usse pehle let me discuss kaise ham promise ko create karenge aur kaise ham promise ko consume karenge

Impliment a set of dummy functions which can mimic the bahaviour of the following functions 
    1. download -> this function should mimic the download of some content to the file. 
    2. writefile -> this function should mimic writing of some content to a file. 
    3. upload -> this function should mimic uploading a file to the server

        function download(url,callback){
            console.log('downloading data from the url', url)
            setTimeout(()=>{
                console.log('downloading data from the url is completed')
                let Downloaddata = "someData"
                callback(Downloaddata)
            },3000)
        }
        
        function writeFile(data, filename, callback){
            console.log('writting',data,'to the file',filename)
            setTimeout(()=>{
                console.log('writting data to the file is over')
                let status = "successfully"
                callback(status)
            },4000)
        }
        
        function upload(filename,link,status, callback){
            console.log('uploading file to the',link)
            setTimeout(()=>{
                console.log('uploaded',filename,status)
                let msg = "everything done successfully"
                callback(msg)
        
            },5000)
        }
        
        download('www.google.com', function writeData(data){
            writeFile(data, 'file.txt', function uploadData(status){
                upload('file.txt', 'googleDriev',status, function Over(msg){
                    console.log(msg)
                })  
            })
        })

i can write the same function by using promise also.